# Conformance Test: Explicit Type Annotations
# Tests: all declarations require explicit type annotations
# Expected: Compiles without errors, all types work correctly

# ============================================
# Variables with Explicit Types (top-level)
# ============================================

# byte range (0-255)
byte_val: byte = 10
byte_max: byte = 255

# word range (256-65535)
word_val: word = 1000
word_boundary: word = 256
word_max: word = 65535

# sbyte range (-128 to 127)
sbyte_val: sbyte = -50
sbyte_min: sbyte = -128

# sword range (-32768 to 32767)
sword_val: sword = -1000
sword_min: sword = -32768

# float (decimal literals)
float_val: float = 3.14
float_neg: float = -2.718

# bool
bool_true: bool = true
bool_false: bool = false

# ============================================
# Constants with Explicit Types (using const keyword)
# ============================================

# Byte constants
const MAX: byte = 255
const MIN: byte = 0

# Word constants
const LARGE: word = 1000
const MAX_WORD: word = 65535

# Signed constants
const NEGATIVE: sbyte = -100
const BIG_NEG: sword = -1000

# Floating point constants
const PI: fixed = 3.14159
const HALF: fixed = 0.5
const E: float = 2.71828
const DECIMAL: float = 2.5

# ============================================
# Mixed declarations
# ============================================

explicit_byte: byte = 42
explicit_word: word = 1234

def main():
    # Use variables
    a: byte = byte_val + 5
    b: word = word_val + 100

    # Use constants
    c: byte = MAX - 10
    d: word = LARGE * 2

    # Use word-typed constants
    e: word = MAX_WORD - 1
    f: fixed = PI * 2
    g: float = E + 1.0

    # Use signed values
    h: sbyte = sbyte_val + 10
    i: sword = sword_val + 500

    # Use bool
    if bool_true:
        pass

    # Use float
    j: float = float_val + 1.0

    # Print some values
    println("EXPLICIT TYPES:")
    println(a)
    println(b)
    println(c)
